Everything is an object :

Primitives :
Numbers
strings
booleans
undefined
null 

Everything else : 
Arrays
functions
objects
dates
wrappers for numbers,strings,booleans; all are objects

1.Every oject in js has prototype property which makes Inheritance possible.
2.The prototype property of an object is where we put methods and properties that we want other objects to Inherit
3.The Constructor prototype is not a prototype of itself but its the prototype of all the instances that are created through it
4.When a certain method or property is called, the search starts in object itself. and if it cant found the search moves on objects prototype.
This continues until method is found. This is called protochain.

Function cunstructor and we use prototype to assign the method or property not in the Constructor itself but you have to call them its ideal for methods not for property.

Constructor is like a class 
Constructor & instances

new -- operator creates a empty object

Console : 
john -- gets all the information of this object
Person.prototype  -- 
john.__proto__ === Person.prototype
john.hasOwnProperty('lastName')
console.info(x)

a = 3 ; b = a ; a = 4  //result will be a = 4 ; b = 3;
var obj1 = {
    name: 'zia',
    age : 35
}

var obj2 = obj1
obj1.age = 30  //result will be obj2 and obj1 = 30 because Primitives assign a storage but objects just has reference not copy

var ages = 27;
var obj = {
    name : 'mehbul',
    city : 'San Francisco'
}

function change(a,b) {
    a = 30;
    b.city = 'London'
}

change(ages,obj);
console.log(ages);
console.log(obj.city);    //result will be ages = 27 since it is a Primitives and obj.city will be changed to London. Because

Generic Function , Callback Function
calc(array, calculateAge);  -- This calculateAge function is a callback function because we are not calling this function by putting paranthesis.




Returning function: 

var answer = interview('teacher');
answer('john')
interview('designer') ('Mark');

IIFY :
(function () {
    score = Math.random() * 10;
    console.log(score >= 5);
}) ();

(function (goodLuck) {
    var score = Math.random() * 10;
    console.log(score >= 5 - goodLuck);
}) (3);

We are using IIFE to secure our code because all variables and functions are inside the function and nobody can interfere with those.

Closures :

An inner function has always accessto the variables and parameters of its outer function,even after the outer function has returned.

When function returns it gone from Execution context but in Scope chain the variables will be stored hence after returning the function also we are able to access those variables.


Call, Apply, Bind :

So the call method changes the 'this' so we can pass other object using the call method.
Apply also same but it takes array as an Arguments. 
Bind method doesnt immediately call the function as the other methods do instead it stores the value in a variable. And then we can use it further.And in bind method we can pass arguments later as well as we can see in the example.


john.presentation.call(emily, 'friendly', 'afternoon');
john.presentation.apply(emily, ['friendly', 'afternoon']);
var johnFriendly = john.presentation.bind(john, 'friendly');